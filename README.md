# Выжимка по работе с Docker

Подноготная структуры Docker и подробно о всех основных функциях собрана в одном месте

## Оглавление
- [Выжимка по работе с Docker](#выжимка-по-работе-с-docker)
  - [Оглавление](#оглавление)
  - [Архитектура Docker](#архитектура-docker)
    - [Отличие Docker от Виртуальных машин](#отличие-docker-от-виртуальных-машин)
    - [Подробная схема работы](#подробная-схема-работы)
  - [Управление контейнерами](#управление-контейнерами)
    - [Жизненный цикл контейнера](#жизненный-цикл-контейнера)
    - [Сигналы процессам](#сигналы-процессам)
    - [Основные команды Docker](#основные-команды-docker)
    - [Логи Docker](#логи-docker)
    - [Команды внутри контейнера](#команды-внутри-контейнера)
  - [Docker Image](#docker-image)
  - [Сети Docker](#сети-docker)
  - [Docker volumes](#docker-volumes)
  - [Docker-compose](#docker-compose)
  - [Docker registry](#docker-registry)

## Архитектура Docker

### Отличие Docker от Виртуальных машин

Простыми словами ключевое отличие это отстутсвие у Docker гостевой OS. Docker ничего общего не имеет с виртуальными машинами, разве что только изолированность. 

[![Docker-vs-VM.jpg](https://i.postimg.cc/wv5KBDG2/Docker-vs-VM.jpg)](https://postimg.cc/zbf2tH5H)

Вся суть в процессах работы Linux. К примеру при запуске работы приложения на Nodejs первым делом запускается новый процесс с помощью внутреннего вызова комманды `fork`, который создаст новый процесс, при этом скоппировав предидущий процесс. Поэтому будет `Bash` потом `fork` потом второй `Bash` после этого подменяется новым процессом. Это делается с помощью комманды `execv` это заменит текущий процесс замененого `Bash` на текущий процесс ноды. У этого процесса появится свой process ID и он будет уже функционировать уже в рамках этого process ID. 

Этот процесс он при этом не является изолированным. Поскольку если другой процесс занимает ту же часть диска, то удалит текущий процесс. Эта проблема изорилованности процессов была до тех пор, пока в Linux не появилась команда `chroot` - эта комманда позволяет получить прообраз изоляции с помощью изменения root директории. В Docker используется конечно же не `chroot`, там используются `namespaces`. Но это некая аналогия, которая показывает как работает Docker. Запускается процесс, потом ему изменяют root директорию на какую-то кастомную и он не будет видеть никакие другие соответствующие бинарники, папки и прочее внутри своего изолированного пространства. Он также может скопировать необходимые другие бинарники и запускатся уже с ними.

[![Docker-container-namespace.jpg](https://i.postimg.cc/VNYnTwcN/Docker-container-namespace.jpg)](https://postimg.cc/cvbvgVCq)

Когда запускается новый процесс, то Docker открывает новый `namespace`. Фактически, когда мы запускаем контейнер, мы запускаем новый `Namespace`. Он имеет несколько наборов, так званные СGroups. Которые управляют ограничениями по памяти. IPC - это управления процесами, которые позволяют создавать изолированость и общение в namespace. Свой network. Mount который говорит какие директории доступны, которые доступны и какие нет. Process ID, который может повторятся с process ID текущего, то есть при запуске на хосте, process ID является уникальным, то в namespace process ID может быть свой. User, который может быть своим по аналогии с process ID. 

Кроме этого в Docker существуют некоторые обвязки, которые обвязывают все эти параметры namespace и непосредственно какие-то Vоlume и т.д.

Поэтому по сути контейнер это некая изолированная часть, изолированный namespace, который запускается на ядре хостовой машины и функционирует полностью изолировано кроме того, что оно получает доступ к ресурсам этой машины. Благодаря этой изоляции мы получаем полностью изолированное пространство в котором мы можем делать ряд различных вещей и кроме того можно запускать разные библиотеки, тем самым на одном ядре может например находится Gem Linux, а на другом namespace - Ubuntu. 

**Поэтому контейнер это не виртуальная машина, это изолированный namespace с дополнительными обвязками Docker в котором у нас запускается приложение, запускаются различные библиотеки с соответствующим ядром и после этого этот контейнер стартует и позволяет с ним работать с помощью удобного API.**

[![Docker-Engine.jpg](https://i.postimg.cc/QMxS71CS/Docker-Engine.jpg)](https://postimg.cc/XrmwSZwy)

Сам Docker не имеет ядра и поэтому мы не можем запускать процессы для одной архитектуре и запускать на другой архитектуре. То есть Docker не позволяет делать эмуляцию между процессами, поэтому если контейнер был запущен на архитектуре х64, то он успешно откроется только на такой архитектуре, а не на армовской или ещё какой-либо другой. 

Внутри Docker состоит из трёх частей и когда, например, вводится комманда `Docker ps` то это работа не с самим docker'ром, а с клиентом внутри docker'а. Это просто удобная СLI утилита. 


### Подробная схема работы

[![image.jpg](https://i.postimg.cc/7PpBR5tY/image.jpg)](https://postimg.cc/3WFC4xHP)

У нас есть клиент - тот самый клиент из которого вводятся комманды по типу `docker рs` и всё что угодно. После этого делается запрос к API к хосту, на этом хосте крутится Docker daemon, Docker daemon проверяет есть ли у нас такой image внутри, в наличии локально. Если такой image нету, то daemon пошел скачивать его из общего регистра, например пошел на Docker hub. После этого он скачивает нужный image и запускать новый контейнер. На самом деле всё что он делает это создаёт новый namespace и передаёт туда этот Image. Кладёт туда нужные либы и распаковывает этот image, чтобы всё запустить. 






В Docker есть следующий типы объектов:
  - Builder
  - Config
  - Container
  - Context
  - Engine
  - Image
  - Network
  - Node
  - Plugin
  - Secret
  - Service
  - Stack
  - Swarm
  - System
  - Trust
  - Volume

## Управление контейнерами

`Docker container` - это сущность отвечающая за работу с контейнерами.  <br/>
Но название `container` можно опускать, поскольку в большинстве комманд он по умолчанию устроен под container, поскольку при работе с Docker очень приходится работать именно с container и поэтому команды работы с контейнерами вынесены на верхний уровень. Из-за этого следующие команды равны по своей сущности:  <br/>
`docker start` - `docker container start` <br/>
`docker stop` - `docker container stop`

### Жизненный цикл контейнера

Когда мы делаем `docker run` у нас скачивается `image`. Этот `Image` запускается и превращается в контейнер. После того как мы запустили контейнер у нас появляется жизненный цикл контейнера:

[![image.jpg](https://i.postimg.cc/vBhnvg6m/image.jpg)](https://postimg.cc/47Knf3PC)

Когда мы запустили контейнер, у него появляется жизненный этап `running`. Запускается наше приложение и контейнер работает.
Когда нужно остановить контейнер то необходимо использовать команду `docker stop`, которая приводит контейнер в состояние - `stopped`. 
Когда нужно контейнер уничтожить контейнер, то необходимо использовать команду `docker kill`. 
Когда нужно перезагрузить контейнер, то нужна команда `docker restart`. 
Когда нужно поставить контейнер на паузу, то нужна команда `docker pause`.
Если нужно удалить контейнер, то используется команда `docker rm` 
Если нужно удалить контейнер, даже если он запущен, тогда необходимо применить команду `docker rm -f`.

### Сигналы процессам

Каждая команда сопровождается сигналом, который позволяет нам завершить процесс:
| Комманда Docker | Сигнал | Пояснение |
| :-------------: | :----- | :-------- |
| docker stop | SIGTERM <br/> SIGKILL | При введении команды, Docker'у посылается команда SIGTERM, которая завершает процесс, но если в течении какого-то времени контейнер не останавливается, то через какое-то время Docker с помощью сигнала SIGNKILL убьёт этот контейнер. То есть даже если контейнер повис, Docker всё равно его убьёт |
| docker pause | SIGNSTOP | Ставит контейнер на паузу |
| docker kill | SIGNKILL | Убивает контейнер, даже если он повис |

### Основные команды Docker

| Комманда | Синтаксис | Пояснение |
| :------: | :-------- | :-------- |
| run --name | docker run --name <container_name> | Создание контейнера с указанным именем | 
| start | docker container start <container_name> | Запуск контейнера с указанным именем | 
| stop | docker container stop <container_name> | Остановка контейнера с указанным именем | 
| ps -a | docker ps -a | Вывести все (как запущенные так и остановленные) контейнеры | 
| ps  | docker ps | Вывести все запущенные контейнеры | 
| remove | docker container remove <container_name> | Удалить контейнера с указанным именем | 
| prune | docker container prune | Удалить все остановленные контейнеры | 
| rename | docker remae <old_container_name> <new_container_name> | Переименовать контейнер с указанным именем на новое имя |
| stats | docker stats | Выводит статистику по всем контейнерам в реальном времени таких параметров как: ЦПУ, использование памяти, выход и выход сети, ID процесса и т.д. |
| inspect | docker inspect <container_name> | Получить всю подробную информацию о контейнере в формате JSON, в том числе State, ID процесс или Image`и с которых был сделан контейнер |
| inspect -s | docker inspect -s <container_name> | Получить размер контейнера |
| inspect -f "{{.field}}" | docker inspect -f "{{.field.field}}" <container_name> | Получить детали конкретной строчки из JSON |

### Логи Docker

Контейнер на протяжении своего жизненного цикла создаёт логи. Чтобы получить все логи конкретного контейнера необходимо ввести комманду:
```
docker logs <container_name>
```

Поскольку лента логов достаточно длинная и поэтому слабо читабельная, то уже с помощью команд Linux есть возможность витянуть из логов что-то конкретное. 
Для этого необходимо использовать оператор пайпа ( | ), чтобы передать результаты предидущей команды в следующую команды, а также использовать функцию `grep`. Функция `grep` позволяет вытащить необходимый кусок текста описывая регулярные выражения в RegExp внутри запроса. 

| Синтаксис | Пояснение |
| :-------- | :-------- |
| docker logs <container_name> \ grep `id` | Выводит все строки содержащие id |
| docker logs <container_name> \ grep `id` -A 10 | Выводит 10 строк после нахождения строки содержащую id |
| docker logs <container_name> \ grep `id` -В 15 | Выводит 15 строк до нахождения строки содержащую id |
| docker logs <container_name> \ grep `id` -m 2 | Выводит 2 первых строки содержащие id |
| docker logs <container_name> text.txt | Сохранить логи, которые будут выведены в файл text.txt |

### Команды внутри контейнера 

Порой необходимо войти в контейнер руками, чтобы что-нибудь сделать, подправить или посмотреть


## Docker Image

## Сети Docker

## Docker volumes

## Docker-compose

## Docker registry



